{
  "version": 3,
  "sources": ["../../@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js", "../../@smithy/core/dist-es/submodules/event-streams/index.js"],
  "sourcesContent": ["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\r\nexport class EventStreamSerde {\r\n    marshaller;\r\n    serializer;\r\n    deserializer;\r\n    serdeContext;\r\n    defaultContentType;\r\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\r\n        this.marshaller = marshaller;\r\n        this.serializer = serializer;\r\n        this.deserializer = deserializer;\r\n        this.serdeContext = serdeContext;\r\n        this.defaultContentType = defaultContentType;\r\n    }\r\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\r\n        const marshaller = this.marshaller;\r\n        const eventStreamMember = requestSchema.getEventStreamMember();\r\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\r\n        const serializer = this.serializer;\r\n        const defaultContentType = this.defaultContentType;\r\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\r\n        const eventStreamIterable = {\r\n            async *[Symbol.asyncIterator]() {\r\n                if (initialRequest) {\r\n                    const headers = {\r\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\r\n                        \":message-type\": { type: \"string\", value: \"event\" },\r\n                        \":content-type\": { type: \"string\", value: defaultContentType },\r\n                    };\r\n                    serializer.write(requestSchema, initialRequest);\r\n                    const body = serializer.flush();\r\n                    yield {\r\n                        [initialRequestMarker]: true,\r\n                        headers,\r\n                        body,\r\n                    };\r\n                }\r\n                for await (const page of eventStream) {\r\n                    yield page;\r\n                }\r\n            },\r\n        };\r\n        return marshaller.serialize(eventStreamIterable, (event) => {\r\n            if (event[initialRequestMarker]) {\r\n                return {\r\n                    headers: event.headers,\r\n                    body: event.body,\r\n                };\r\n            }\r\n            const unionMember = Object.keys(event).find((key) => {\r\n                return key !== \"__type\";\r\n            }) ?? \"\";\r\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\r\n            const headers = {\r\n                \":event-type\": { type: \"string\", value: eventType },\r\n                \":message-type\": { type: \"string\", value: \"event\" },\r\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\r\n                ...additionalHeaders,\r\n            };\r\n            return {\r\n                headers,\r\n                body,\r\n            };\r\n        });\r\n    }\r\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\r\n        const marshaller = this.marshaller;\r\n        const eventStreamMember = responseSchema.getEventStreamMember();\r\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\r\n        const memberSchemas = unionSchema.getMemberSchemas();\r\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\r\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\r\n            const unionMember = Object.keys(event).find((key) => {\r\n                return key !== \"__type\";\r\n            }) ?? \"\";\r\n            const body = event[unionMember].body;\r\n            if (unionMember === \"initial-response\") {\r\n                const dataObject = await this.deserializer.read(responseSchema, body);\r\n                delete dataObject[eventStreamMember];\r\n                return {\r\n                    [initialResponseMarker]: true,\r\n                    ...dataObject,\r\n                };\r\n            }\r\n            else if (unionMember in memberSchemas) {\r\n                const eventStreamSchema = memberSchemas[unionMember];\r\n                if (eventStreamSchema.isStructSchema()) {\r\n                    const out = {};\r\n                    let hasBindings = false;\r\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\r\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\r\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\r\n                        if (eventPayload) {\r\n                            if (member.isBlobSchema()) {\r\n                                out[name] = body;\r\n                            }\r\n                            else if (member.isStringSchema()) {\r\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\r\n                            }\r\n                            else if (member.isStructSchema()) {\r\n                                out[name] = await this.deserializer.read(member, body);\r\n                            }\r\n                        }\r\n                        else if (eventHeader) {\r\n                            const value = event[unionMember].headers[name]?.value;\r\n                            if (value != null) {\r\n                                if (member.isNumericSchema()) {\r\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\r\n                                        out[name] = BigInt(value.toString());\r\n                                    }\r\n                                    else {\r\n                                        out[name] = Number(value);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    out[name] = value;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (hasBindings) {\r\n                        return {\r\n                            [unionMember]: out,\r\n                        };\r\n                    }\r\n                    if (body.byteLength === 0) {\r\n                        return {\r\n                            [unionMember]: {},\r\n                        };\r\n                    }\r\n                }\r\n                return {\r\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    $unknown: event,\r\n                };\r\n            }\r\n        });\r\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\r\n        const firstEvent = await asyncIterator.next();\r\n        if (firstEvent.done) {\r\n            return asyncIterable;\r\n        }\r\n        if (firstEvent.value?.[initialResponseMarker]) {\r\n            if (!responseSchema) {\r\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\r\n            }\r\n            for (const [key, value] of Object.entries(firstEvent.value)) {\r\n                initialResponseContainer[key] = value;\r\n            }\r\n        }\r\n        return {\r\n            async *[Symbol.asyncIterator]() {\r\n                if (!firstEvent?.value?.[initialResponseMarker]) {\r\n                    yield firstEvent.value;\r\n                }\r\n                while (true) {\r\n                    const { done, value } = await asyncIterator.next();\r\n                    if (done) {\r\n                        break;\r\n                    }\r\n                    yield value;\r\n                }\r\n            },\r\n        };\r\n    }\r\n    writeEventBody(unionMember, unionSchema, event) {\r\n        const serializer = this.serializer;\r\n        let eventType = unionMember;\r\n        let explicitPayloadMember = null;\r\n        let explicitPayloadContentType;\r\n        const isKnownSchema = (() => {\r\n            const struct = unionSchema.getSchema();\r\n            return struct[4].includes(unionMember);\r\n        })();\r\n        const additionalHeaders = {};\r\n        if (!isKnownSchema) {\r\n            const [type, value] = event[unionMember];\r\n            eventType = type;\r\n            serializer.write(15, value);\r\n        }\r\n        else {\r\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\r\n            if (eventSchema.isStructSchema()) {\r\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\r\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\r\n                    if (eventPayload) {\r\n                        explicitPayloadMember = memberName;\r\n                    }\r\n                    else if (eventHeader) {\r\n                        const value = event[unionMember][memberName];\r\n                        let type = \"binary\";\r\n                        if (memberSchema.isNumericSchema()) {\r\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\r\n                                type = \"integer\";\r\n                            }\r\n                            else {\r\n                                type = \"long\";\r\n                            }\r\n                        }\r\n                        else if (memberSchema.isTimestampSchema()) {\r\n                            type = \"timestamp\";\r\n                        }\r\n                        else if (memberSchema.isStringSchema()) {\r\n                            type = \"string\";\r\n                        }\r\n                        else if (memberSchema.isBooleanSchema()) {\r\n                            type = \"boolean\";\r\n                        }\r\n                        if (value != null) {\r\n                            additionalHeaders[memberName] = {\r\n                                type,\r\n                                value,\r\n                            };\r\n                            delete event[unionMember][memberName];\r\n                        }\r\n                    }\r\n                }\r\n                if (explicitPayloadMember !== null) {\r\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\r\n                    if (payloadSchema.isBlobSchema()) {\r\n                        explicitPayloadContentType = \"application/octet-stream\";\r\n                    }\r\n                    else if (payloadSchema.isStringSchema()) {\r\n                        explicitPayloadContentType = \"text/plain\";\r\n                    }\r\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\r\n                }\r\n                else {\r\n                    serializer.write(eventSchema, event[unionMember]);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\r\n            }\r\n        }\r\n        const messageSerialization = serializer.flush();\r\n        const body = typeof messageSerialization === \"string\"\r\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\r\n            : messageSerialization;\r\n        return {\r\n            body,\r\n            eventType,\r\n            explicitPayloadContentType,\r\n            additionalHeaders,\r\n        };\r\n    }\r\n}\r\n", "export * from \"./EventStreamSerde\";\r\n"],
  "mappings": "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",
  "names": []
}
